#include <glib.h>
#include <gst/gl/gl.h>

struct Accumulator {
        GLfloat frozen;
        GLfloat black;
        GLfloat bright;
        GLfloat diff;
        GLfloat noize;
        GLint   visible;
};

static const char* shader_source =
        "#version 430\n"
        "#extension GL_ARB_compute_shader : enable\n"
        "#extension GL_ARB_shader_storage_buffer_object : enable\n"
        "\n"
        //"precision highp float;\n"
        "\n"
        "#define WHT_LVL 210\n"
        "// 210 //0.90196078\n"
        "#define BLK_LVL 40\n"
        "// 40 //0.15625\n"
        "#define WHT_DIFF 6\n"
        "// 6 //0.0234375\n"
        "#define GRH_DIFF 2\n"
        "// 2 //0.0078125\n"
        "#define KNORM 4\n"
        "#define L_DIFF 5\n"
        "\n"
        "#define BLOCK_SIZE 8\n"
        "\n"
        "struct Noize {\n"
        "        float frozen;\n"
        "        float black;\n"
        "        float bright;\n"
        "        float diff;\n"
        "        float noize;\n"
        "        int   visible;\n"
        "};\n"
        "\n"
        "layout (r8) uniform image2D tex;\n"
        "layout (r8) uniform image2D tex_prev;\n"
        "uniform int width;\n"
        "uniform int height;\n"
        "uniform int stride;\n"
        "uniform int black_bound;\n"
        "uniform int freez_bound;\n"
        "\n"
        "layout (std430, binding=10) buffer Interm {\n"
        "         Noize noize_data [];\n"
        "};\n"
        "\n"
        "layout (local_size_x = BLOCK_SIZE, local_size_y = BLOCK_SIZE, local_size_z = 1) in; \n"
        "\n"
        "        shared int noize;"
        "        shared int bright;"
        "        shared int diff_counter;"
        "        shared int black;"
        "        shared int frozen;"
        "\n"
        "int abs_int(int x) { return x * sign(x); } \n"
        "\n"
        "void main() {\n"
        "        uint  block_pos = (gl_WorkGroupID.y * (width / BLOCK_SIZE)) + gl_WorkGroupID.x;\n"
        "        ivec2 pix_pos   = ivec2(gl_GlobalInvocationID.xy);\n"                      
        "\n"
        "        /* init shared*/\n"
        "        if (gl_LocalInvocationID.xy == ivec2(0,0)) {\n"
        "             noize = 0;\n"
        "             bright = 0;\n"
        "             diff_counter = 0;\n"
        "             black = 0;\n"
        "             frozen = 0;\n"
        "        }\n"
        "        memoryBarrierShared();"
        "        barrier();"
        "\n"
        "        int   pix       = int(imageLoad(tex, pix_pos).r * 255.0);\n"
        "        int   pix_right = int(imageLoad(tex, ivec2(pix_pos.x + 1, pix_pos.y)).r * 255.0);\n"
        "        int   pix_down  = int(imageLoad(tex, ivec2(pix_pos.x, pix_pos.y + 1)).r * 255.0);\n"
        "        /* Noize */\n"
        "        int   lvl = WHT_DIFF;\n"
        "        if ((pix < WHT_LVL) && (pix > BLK_LVL)) {\n"
        "              lvl = GRH_DIFF;\n"
        "        }\n"
        "        if (abs(pix - pix_right) > lvl) {\n"
        "            atomicAdd(noize, 1);\n"
        "        }\n"
        "        if (abs(pix - pix_down) > lvl) {\n"
        "            atomicAdd(noize, 1);\n"
        "        }\n"
        "        /* Brightness */\n"
        "        atomicAdd(bright, pix);\n"
        "        /* Black */\n"
        "        if (pix <= black_bound) {\n"
        "            atomicAdd(black, 1);\n"
        "        }\n"
        "        /* Diff */\n"
        "        int   pix_prev = int(imageLoad(tex_prev, pix_pos).r * 255.0);\n"
        "        int   diff_pix = abs_int(pix - pix_prev);\n"
        "        atomicAdd(diff_counter, diff_pix);\n"
        "        /* Frozen */\n"
        //       TODO consider diff_pid = int(abs(imageLoad(tex_prev, pix_pos).r - imageLoad(tex, pix_pos).r) * 255.0)
        //       TODO <=
        "        if (diff_pix < freez_bound) {\n"
        "            atomicAdd(frozen, 1);\n"
        "        }\n"
        "        memoryBarrierShared();"
        "        barrier();"
        "        /* Store results */\n"
        "        if (gl_LocalInvocationID.xy == ivec2(0,0)) {\n"
        "            noize_data[block_pos].noize  = float(noize) / (8.0 * 8.0 * 2.0);\n"
        "            noize_data[block_pos].black  = float(black);\n"
        "            noize_data[block_pos].frozen = float(frozen);\n"
        "            noize_data[block_pos].bright = float(bright) / 256.0;\n"
        "            noize_data[block_pos].diff   = float(diff_counter);\n"
        "            noize_data[block_pos].visible = 0;\n"
        "        }\n"    
        "}\n";

static const char* shader_source_block =
        "#version 430\n"
        "#extension GL_ARB_compute_shader : enable\n"
        "#extension GL_ARB_shader_image_load_store : enable\n"
        "#extension GL_ARB_shader_storage_buffer_object : enable\n"
        "\n"
        "//precision lowp float;\n"
        "\n"
        "#define WHT_LVL 0.90196078\n"
        "// 210\n"
        "#define BLK_LVL 0.15625\n"
        "// 40\n"
        "#define WHT_DIFF 0.0234375\n"
        "// 6\n"
        "#define GRH_DIFF 0.0078125\n"
        "// 2\n"
        "#define KNORM 4.0\n"
        "#define L_DIFF 5\n"
        "\n"
        "#define BLOCK_SIZE 8\n"
        "\n"
        "struct Noize {\n"
        "        float frozen;\n"
        "        float black;\n"
        "        float bright;\n"
        "        float diff;\n"
        "        float noize;\n"
        "        int   visible;\n"
        "};\n"
        "\n"
        "layout (r8, binding = 0) uniform image2D tex;\n"
        "\n"
        "uniform int width;\n"
        "uniform int height;\n"
        "\n"
        "layout (std430, binding=10) buffer Interm {\n"
        "         Noize noize_data [];\n"
        "};\n"
        "\n"
        "//const uint wht_coef[20] = {8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 14, 17, 27};\n"
        "//const uint ght_coef[20] = {4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 10, 13, 23};\n"
        "//const uint wht_coef[20] = {10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 16, 19, 29};	       \n"
        "//const uint ght_coef[20] = {6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 10, 12, 15, 25};\n"
        "const uint wht_coef[20] = {6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 9, 9, 10, 12, 15, 25};\n"
        "const uint ght_coef[20] = {2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 8, 11, 21};\n"
        "\n"
        "/* x = Edge pixel offset, y = Edge ID */\n"
        "layout (local_size_x = 8, local_size_y = 4, local_size_z = 1) in;\n"
        "\n"
        "float get_coef(float noize, uint array[20]) {\n"
        "        uint ret_val;                                     \n"
        "        if((noize>100) || (noize<0))\n"
        "                ret_val = 0;                              \n"
        "        else                                              \n"
        "                ret_val = array[uint(noize/5)];                 \n"
        "        return float(ret_val/255.0);\n"
        "}\n"
        "\n"
        "int abs_int(int x) { return x * sign(x); } \n"
        "\n"
        "void main() {\n"
        "        uint block_pos = (gl_WorkGroupID.y * (width / BLOCK_SIZE)) + gl_WorkGroupID.x;\n"
        "        /* l d r u */\n"
        "        uint pixel_off = gl_LocalInvocationID.x;\n"
        "        uint edge = gl_LocalInvocationID.y;\n"
        "        /* l (-1, 0) d (0, -1) r (1, 0) u (0, 1) */ \n"
        "        ivec2 edge_off = ivec2 ( mod(edge + 1, 2) * int(edge - 1),\n"
        "                                 mod(edge, 2) * int(edge - 2));\n"
        "\n"
        "        /* Would not compute blocks near the borders */\n"
        "        if (gl_WorkGroupID.x == 0\n"
        "            || gl_WorkGroupID.x >= (width / BLOCK_SIZE)\n"
        "            || gl_WorkGroupID.y == 0\n"
        "            || gl_WorkGroupID.y >= (height / BLOCK_SIZE))\n"
        "                return;\n"
        "\n"
        "        shared int loc_counter;\n"
        "        shared int vis[4];\n"
        "        /* Noize coeffs */\n"
        "        uint pos = block_pos + edge_off.x + (edge_off.y * width / BLOCK_SIZE);\n"
        "        float noize = 100.0 * max(noize_data[block_pos].noize, noize_data[pos].noize);\n"
        "        float white = get_coef(noize, wht_coef);\n"
        "        float grey  = get_coef(noize, ght_coef);\n"
        "\n"
        "        if (gl_LocalInvocationID.x == 0) {\n"
        "\n"
        "                loc_counter = 0;\n"
        "                atomicExchange(vis[edge], 0);\n"
        "\n"
        "        }\n"
        "\n"
        "        ivec2 zero = ivec2(gl_WorkGroupID.x * BLOCK_SIZE,\n"
        "                           gl_WorkGroupID.y * BLOCK_SIZE);\n"
        "        float pixel = imageLoad(tex, ivec2(zero.x + abs_int(edge_off.y) * pixel_off +\n"
        "                                           (edge_off.x == 1 ? (BLOCK_SIZE-1) : 0),\n"
        "                                           zero.y + abs_int(edge_off.x) * pixel_off +\n"
        "                                           (edge_off.y == 1 ? (BLOCK_SIZE-1) : 0))).r;\n"
        "        float prev  = imageLoad(tex, ivec2(zero.x + abs_int(edge_off.y) * pixel_off + \n"
        "                                           (edge_off.x == 1 ? (BLOCK_SIZE-2) : 0) + \n"
        "                                           (edge_off.x == -1 ? 1 : 0), \n"
        "                                           zero.y + abs_int(edge_off.x) * pixel_off + \n"
        "                                           (edge_off.y == 1 ? (BLOCK_SIZE-2) : 0) + \n"
        "                                           (edge_off.y == 1 ? 1 : 0))).r;\n"
        "        float next  = imageLoad(tex, ivec2(zero.x + abs_int(edge_off.y) * pixel_off + \n"
        "                                           (edge_off.x == 1 ? BLOCK_SIZE : 0) + \n"
        "                                           (edge_off.x == -1 ? -1 : 0),\n"
        "                                           zero.y + abs_int(edge_off.x) * pixel_off + \n"
        "                                           (edge_off.y == 1 ? BLOCK_SIZE : 0) + \n"
        "                                           (edge_off.y == 1 ? -1 : 0))).r;\n"
        "        float next_next  = imageLoad(tex, ivec2(zero.x + abs_int(edge_off.y) * pixel_off + \n"
        "                                                (edge_off.x == 1 ? (BLOCK_SIZE+1) : 0) + \n"
        "                                                (edge_off.x == -1 ? -2 : 0), \n"
        "                                                zero.y + abs_int(edge_off.x) * pixel_off + \n"
        "                                                (edge_off.y == 1 ? (BLOCK_SIZE+1) : 0) + \n"
        "                                                (edge_off.y == 1 ? -2 : 0))).r;\n"
        "        float coef = ((pixel < WHT_LVL) && (pixel > BLK_LVL)) ? grey : white;\n"
        "        float denom = round( (abs(prev-pixel) + abs(next-next_next) ) / KNORM);\n"
        "        denom = (denom == 0.0) ? 1.0 : denom;\n"
        "        float norm = abs(next-pixel) / denom;\n"
        "        \n"
        "        if (norm > coef)\n"
        "                atomicAdd(vis[edge], 1);\n"
        "\n"
        "        /* counting visible blocks */\n"
        "\n"
        "        if (gl_LocalInvocationID.x == 0) {\n"
        "                if (vis[edge] > L_DIFF)\n"
        "                        atomicAdd(loc_counter, 1);\n"
        "        }\n"
        "\n"
        "        barrier();\n"
        "\n"
        "        if (gl_LocalInvocationID.xy == ivec2(0,0)) {\n"
        "                if (loc_counter >= 2)\n"
        "                        noize_data[block_pos].visible = 1;\n"
        "        }\n"
        "}\n";
